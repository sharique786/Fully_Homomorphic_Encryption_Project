<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FHE Financial Data Processor - Technical Documentation</title>
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #fff;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20px;
        }

        .cover-page {
            text-align: center;
            padding: 100px 20px;
            page-break-after: always;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            margin-bottom: 40px;
        }

        .cover-page h1 {
            font-size: 42px;
            margin-bottom: 20px;
            font-weight: 700;
        }

        .cover-page h2 {
            font-size: 24px;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        .cover-page .metadata {
            margin-top: 60px;
            font-size: 16px;
        }

        .toc {
            page-break-after: always;
            padding: 20px;
        }

        .toc h2 {
            color: #667eea;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .toc ul {
            list-style: none;
            padding-left: 0;
        }

        .toc li {
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .toc a {
            text-decoration: none;
            color: #333;
            display: flex;
            justify-content: space-between;
        }

        .toc a:hover {
            color: #667eea;
        }

        .section {
            page-break-inside: avoid;
            margin-bottom: 40px;
            padding: 20px;
        }

        h1 {
            color: #667eea;
            font-size: 32px;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h2 {
            color: #764ba2;
            font-size: 26px;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h3 {
            color: #667eea;
            font-size: 20px;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        h4 {
            color: #555;
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
        }

        p {
            margin-bottom: 12px;
            text-align: justify;
        }

        .info-box {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }

        th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #c7254e;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-size: 13px;
        }

        .architecture-diagram {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .flow-step {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            position: relative;
        }

        .flow-step::after {
            content: '‚Üì';
            display: block;
            text-align: center;
            font-size: 24px;
            margin-top: 10px;
        }

        .flow-step:last-child::after {
            display: none;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .comparison-card {
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }

        .comparison-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .stat-highlight {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 15px 0;
        }

        .stat-highlight .value {
            font-size: 36px;
            font-weight: bold;
            display: block;
            margin: 10px 0;
        }

        .stat-highlight .label {
            font-size: 14px;
            opacity: 0.9;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .feature-list {
            list-style: none;
            margin-left: 0;
        }

        .feature-list li::before {
            content: '‚úì';
            color: #28a745;
            font-weight: bold;
            margin-right: 10px;
        }

        @media print {
            .section {
                page-break-inside: avoid;
            }

            h1, h2, h3 {
                page-break-after: avoid;
            }
        }

        .btn-download {
            background: #667eea;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            display: inline-block;
        }

        .btn-download:hover {
            background: #764ba2;
        }

        .print-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        @media print {
            .print-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="print-controls">
        <button class="btn-download" onclick="window.print()">üìÑ Print/Save as PDF</button>
    </div>

    <!-- Cover Page -->
    <div class="cover-page">
        <h1>üîê FHE Financial Data Processor</h1>
        <h2>Comprehensive Technical Documentation</h2>
        <p style="font-size: 18px; margin-top: 40px;">
            Privacy-Preserving Financial Transaction Analysis<br>
            Using Fully Homomorphic Encryption
        </p>
        <div class="metadata">
            <p><strong>Version:</strong> 1.0</p>
            <p><strong>Date:</strong> October 2025</p>
            <p><strong>Classification:</strong> Technical Implementation Document</p>
        </div>
    </div>

    <!-- Table of Contents -->
    <div class="toc">
        <h2>üìë Table of Contents</h2>
        <ul>
            <li><a href="#executive-summary"><span>1. Executive Summary</span><span>3</span></a></li>
            <li><a href="#introduction"><span>2. Introduction to FHE</span><span>4</span></a></li>
            <li><a href="#use-case"><span>3. Use Case & Requirements</span><span>5</span></a></li>
            <li><a href="#architecture"><span>4. System Architecture</span><span>7</span></a></li>
            <li><a href="#technical-implementation"><span>5. Technical Implementation</span><span>9</span></a></li>
            <li><a href="#library-comparison"><span>6. Library Comparison</span><span>12</span></a></li>
            <li><a href="#scheme-analysis"><span>7. Scheme Analysis</span><span>14</span></a></li>
            <li><a href="#performance"><span>8. Performance Metrics</span><span>16</span></a></li>
            <li><a href="#security"><span>9. Security Considerations</span><span>18</span></a></li>
            <li><a href="#conclusion"><span>10. Conclusion & Future Work</span><span>20</span></a></li>
        </ul>
    </div>

    <!-- 1. Executive Summary -->
    <div class="section" id="executive-summary">
        <h1>1. Executive Summary</h1>

        <p>The FHE Financial Data Processor represents a groundbreaking approach to analyzing sensitive financial transaction data while maintaining complete data privacy. This system leverages Fully Homomorphic Encryption (FHE) to enable computations on encrypted data without ever decrypting it, ensuring that sensitive customer information remains confidential throughout the entire processing pipeline.</p>

        <div class="stat-highlight">
            <span class="value">100%</span>
            <span class="label">Data Privacy During Processing</span>
        </div>

        <h3>Key Achievements</h3>
        <ul class="feature-list">
            <li>Multi-library support (TenSEAL and OpenFHE) with automatic fallback mechanisms</li>
            <li>Multiple encryption schemes (CKKS, BFV, BGV) for different data types</li>
            <li>Real-time homomorphic operations on financial transactions</li>
            <li>Comprehensive performance benchmarking and comparison framework</li>
            <li>User-friendly interface for non-cryptographic experts</li>
        </ul>

        <div class="info-box">
            <strong>Business Value:</strong> This system enables financial institutions to analyze transaction patterns, detect fraud, and generate insights without exposing raw customer data to analysts or third-party processors, ensuring GDPR and regulatory compliance.
        </div>
    </div>

    <!-- 2. Introduction to FHE -->
    <div class="section" id="introduction">
        <h1>2. Introduction to Fully Homomorphic Encryption</h1>

        <h3>What is FHE?</h3>
        <p>Fully Homomorphic Encryption (FHE) is a cryptographic technique that allows computations to be performed on encrypted data without decrypting it. The results, when decrypted, match those of operations performed on plaintext data.</p>

        <div class="architecture-diagram">
            <div class="flow-step">
                <strong>Step 1: Encryption</strong><br>
                Plaintext Data ‚Üí Encrypted Data
            </div>
            <div class="flow-step">
                <strong>Step 2: Computation</strong><br>
                Operations on Encrypted Data (No Decryption!)
            </div>
            <div class="flow-step">
                <strong>Step 3: Decryption</strong><br>
                Encrypted Results ‚Üí Plaintext Results
            </div>
        </div>

        <h3>Why FHE for Financial Data?</h3>
        <table>
            <tr>
                <th>Challenge</th>
                <th>Traditional Approach</th>
                <th>FHE Solution</th>
            </tr>
            <tr>
                <td>Data Privacy</td>
                <td>Data must be decrypted for processing</td>
                <td>Data remains encrypted during processing</td>
            </tr>
            <tr>
                <td>Regulatory Compliance</td>
                <td>Complex access controls and auditing</td>
                <td>Inherent privacy by design</td>
            </tr>
            <tr>
                <td>Third-party Processing</td>
                <td>Trust-based data sharing</td>
                <td>Zero-trust computation model</td>
            </tr>
            <tr>
                <td>Data Breaches</td>
                <td>Exposure of sensitive information</td>
                <td>Encrypted data is useless to attackers</td>
            </tr>
        </table>

        <h3>FHE Libraries</h3>
        <p>This project implements support for two leading FHE libraries:</p>

        <h4>TenSEAL</h4>
        <ul>
            <li>Python-native library built on Microsoft SEAL</li>
            <li>Easy integration and rapid development</li>
            <li>Supports CKKS and BFV schemes</li>
            <li>Excellent for prototyping and Python-based applications</li>
        </ul>

        <h4>OpenFHE</h4>
        <ul>
            <li>High-performance C++ library with cross-platform support</li>
            <li>Supports CKKS, BFV, and BGV schemes</li>
            <li>Advanced features and optimizations</li>
            <li>Industry-grade implementation for production systems</li>
        </ul>
    </div>

    <!-- 3. Use Case & Requirements -->
    <div class="section" id="use-case">
        <h1>3. Use Case & Requirements</h1>

        <h3>Business Scenario</h3>
        <p>A financial institution needs to analyze customer transaction patterns to detect fraud, assess risk, and generate business intelligence. However, regulatory requirements and privacy concerns prevent analysts from accessing raw customer data directly.</p>

        <div class="success-box">
            <strong>Solution:</strong> The FHE Financial Data Processor enables the institution to perform these analyses on encrypted data, ensuring that analysts never see actual customer information while still generating accurate insights.
        </div>

        <h3>Data Schema</h3>

        <h4>A. User Details Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>user_id</td>
                <td>String</td>
                <td>Unique identifier for each customer</td>
            </tr>
            <tr>
                <td>name</td>
                <td>String</td>
                <td>Customer full name</td>
            </tr>
            <tr>
                <td>address</td>
                <td>String</td>
                <td>Customer residential address</td>
            </tr>
            <tr>
                <td>email</td>
                <td>String</td>
                <td>Contact email address</td>
            </tr>
            <tr>
                <td>phone</td>
                <td>String</td>
                <td>Contact phone number</td>
            </tr>
        </table>

        <h4>B. Account Details Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>user_id</td>
                <td>String</td>
                <td>Foreign key to User Details</td>
            </tr>
            <tr>
                <td>account_number</td>
                <td>String</td>
                <td>Unique account identifier</td>
            </tr>
            <tr>
                <td>account_type</td>
                <td>String</td>
                <td>Savings, Checking, Investment, etc.</td>
            </tr>
            <tr>
                <td>balance</td>
                <td>Numeric</td>
                <td>Current account balance</td>
            </tr>
            <tr>
                <td>opening_date</td>
                <td>Date</td>
                <td>Account creation date</td>
            </tr>
        </table>

        <h4>C. Transaction Details Table</h4>
        <table>
            <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>user_id</td>
                <td>String</td>
                <td>Foreign key to User Details</td>
            </tr>
            <tr>
                <td>transaction_id</td>
                <td>String</td>
                <td>Unique transaction identifier</td>
            </tr>
            <tr>
                <td>account_number</td>
                <td>String</td>
                <td>Associated account</td>
            </tr>
            <tr>
                <td>currency</td>
                <td>String</td>
                <td>Transaction currency (USD, EUR, etc.)</td>
            </tr>
            <tr>
                <td>amount</td>
                <td>Numeric</td>
                <td>Transaction amount</td>
            </tr>
            <tr>
                <td>transaction_date</td>
                <td>Date</td>
                <td>Date and time of transaction</td>
            </tr>
            <tr>
                <td>transaction_type</td>
                <td>String</td>
                <td>Debit, Credit, Transfer, etc.</td>
            </tr>
        </table>

        <h3>Functional Requirements</h3>

        <h4>Screen 1: Data Management</h4>
        <ol>
            <li>Upload CSV files for user, account, and transaction data</li>
            <li>Preview and validate uploaded data</li>
            <li>Select columns for encryption (all or subset)</li>
            <li>Choose FHE library (TenSEAL or OpenFHE)</li>
            <li>Select encryption scheme (CKKS, BFV, or BGV)</li>
            <li>Generate or import cryptographic keys</li>
            <li>Encrypt selected columns</li>
            <li>Export keys for secure storage</li>
        </ol>

        <h4>Screen 2: FHE Operations</h4>
        <ol>
            <li>Query encrypted data by user_id</li>
            <li>Count transactions per user (homomorphically)</li>
            <li>Aggregate transactions by currency</li>
            <li>Filter by date range without decryption</li>
            <li>Calculate transaction patterns and statistics</li>
            <li>Visualize results with charts and graphs</li>
            <li>Export encrypted results</li>
        </ol>

        <h4>Screen 3: Statistics & Comparison</h4>
        <ol>
            <li>Compare encryption schemes (CKKS vs BFV vs BGV)</li>
            <li>Measure encryption/decryption times</li>
            <li>Benchmark operation performance</li>
            <li>Analyze parameter impact on performance</li>
            <li>Compare TenSEAL vs OpenFHE performance</li>
            <li>Display comprehensive performance metrics</li>
            <li>Generate comparison reports</li>
        </ol>
    </div>

    <!-- 4. System Architecture -->
    <div class="section" id="architecture">
        <h1>4. System Architecture</h1>

        <h3>High-Level Architecture</h3>
        <div class="architecture-diagram">
            <h4 style="color: #667eea; margin-bottom: 20px;">System Components</h4>
            <table>
                <tr>
                    <th>Layer</th>
                    <th>Component</th>
                    <th>Technology</th>
                </tr>
                <tr>
                    <td>Presentation</td>
                    <td>Web Interface</td>
                    <td>Streamlit</td>
                </tr>
                <tr>
                    <td>Application</td>
                    <td>Business Logic</td>
                    <td>Python</td>
                </tr>
                <tr>
                    <td>Encryption</td>
                    <td>FHE Wrappers</td>
                    <td>TenSEAL / OpenFHE</td>
                </tr>
                <tr>
                    <td>Data</td>
                    <td>File Storage</td>
                    <td>CSV / Session State</td>
                </tr>
            </table>
        </div>

        <h3>Component Details</h3>

        <h4>1. User Interface Layer (Streamlit)</h4>
        <ul>
            <li><code>main.py</code> - Application entry point and navigation</li>
            <li><code>ui/data_management.py</code> - Data upload and encryption interface</li>
            <li><code>ui/fhe_operations.py</code> - Homomorphic operation controls</li>
            <li><code>ui/statistics.py</code> - Performance visualization and comparison</li>
        </ul>

        <h4>2. FHE Wrapper Layer</h4>
        <ul>
            <li><code>tenseal_wrapper.py</code> - TenSEAL integration with CKKS and BFV</li>
            <li><code>openfhe_wrapper.py</code> - OpenFHE integration with 4 operation modes:
                <ul>
                    <li><strong>Mode 1:</strong> Direct ctypes DLL loading</li>
                    <li><strong>Mode 2:</strong> Custom compiled DLL wrapper</li>
                    <li><strong>Mode 3:</strong> C++ subprocess executable</li>
                    <li><strong>Mode 4:</strong> Pure Python simulation fallback</li>
                </ul>
            </li>
        </ul>

        <h4>3. Utility Layer</h4>
        <ul>
            <li><code>utils/session_state.py</code> - Session management</li>
            <li><code>utils/data_processor.py</code> - Data validation and preprocessing</li>
            <li><code>utils/encryption_helper.py</code> - Encryption orchestration</li>
            <li><code>utils/performance_tracker.py</code> - Metrics collection</li>
        </ul>

        <h3>OpenFHE Multi-Mode Architecture</h3>
        <div class="info-box">
            <p>The OpenFHE wrapper implements a sophisticated 4-tier fallback system to ensure maximum compatibility across different platforms and configurations:</p>
        </div>

        <div class="comparison-grid">
            <div class="comparison-card">
                <h4>Mode 1: Ctypes</h4>
                <p><strong>Best Performance</strong></p>
                <p>Direct loading of OpenFHE DLLs via ctypes for native-speed operations</p>
            </div>
            <div class="comparison-card">
                <h4>Mode 2: Custom DLL</h4>
                <p><strong>High Performance</strong></p>
                <p>Compile custom wrapper DLL with simplified C API for Python integration</p>
            </div>
            <div class="comparison-card">
                <h4>Mode 3: Subprocess</h4>
                <p><strong>Good Performance</strong></p>
                <p>Execute compiled C++ binary via subprocess with JSON communication</p>
            </div>
        </div>
        <div class="comparison-card" style="margin-top: 15px;">
            <h4>Mode 4: Simulation</h4>
            <p><strong>Development Mode</strong></p>
            <p>Pure Python mock implementation for testing without OpenFHE installation</p>
        </div>

        <h3>Data Flow</h3>
        <pre>
1. User uploads CSV files
2. System validates and previews data
3. User selects columns for encryption
4. System generates/imports cryptographic keys
5. Selected columns are encrypted using chosen library/scheme
6. Encrypted data stored in session state
7. User queries encrypted data via UI
8. Homomorphic operations performed on encrypted data
9. Results decrypted and displayed
10. Performance metrics collected and analyzed
        </pre>
    </div>

    <!-- 5. Technical Implementation -->
    <div class="section" id="technical-implementation">
        <h1>5. Technical Implementation</h1>

        <h3>Encryption Workflow</h3>

        <h4>Key Generation</h4>
        <p>Both TenSEAL and OpenFHE require generation of multiple key types for secure FHE operations:</p>

        <table>
            <tr>
                <th>Key Type</th>
                <th>Purpose</th>
                <th>Size (typical)</th>
            </tr>
            <tr>
                <td>Public Key</td>
                <td>Encrypts plaintext data</td>
                <td>~2-4 MB</td>
            </tr>
            <tr>
                <td>Private Key</td>
                <td>Decrypts ciphertext results</td>
                <td>~1-2 MB</td>
            </tr>
            <tr>
                <td>Evaluation Key</td>
                <td>Enables homomorphic operations</td>
                <td>~50-100 MB</td>
            </tr>
            <tr>
                <td>Galois Keys</td>
                <td>Rotation and permutation operations</td>
                <td>~20-50 MB</td>
            </tr>
        </table>

        <div class="warning-box">
            <strong>Security Note:</strong> Private keys must be stored securely and never transmitted over insecure channels. The system allows users to export keys for secure offline storage.
        </div>

        <h4>Data Type Handling</h4>

        <p><strong>Numeric Data (CKKS Scheme):</strong></p>
        <pre>
# TenSEAL CKKS Encryption
encrypted_val = ts.ckks_vector(context, [float(value)])

# OpenFHE CKKS Encryption
plaintext = context.MakeCKKSPackedPlaintext([value])
ciphertext = context.Encrypt(public_key, plaintext)
        </pre>

        <p><strong>Text Data (Encoded to Numeric):</strong></p>
        <pre>
# ASCII encoding
numeric_value = sum([ord(c) for c in str(value)])
encrypted_val = ts.ckks_vector(context, [float(numeric_value)])
        </pre>

        <p><strong>Date Data (Timestamp Encoding):</strong></p>
        <pre>
# Convert to Unix timestamp
timestamp = pd.Timestamp(value).timestamp()
encrypted_val = ts.ckks_vector(context, [float(timestamp)])
        </pre>

        <h3>Homomorphic Operations</h3>

        <h4>Supported Operations</h4>
        <table>
            <tr>
                <th>Operation</th>
                <th>CKKS</th>
                <th>BFV</th>
                <th>BGV</th>
                <th>Use Case</th>
            </tr>
            <tr>
                <td>Addition</td>
                <td>‚úì</td>
                <td>‚úì</td>
                <td>‚úì</td>
                <td>Sum of transactions</td>
            </tr>
            <tr>
                <td>Subtraction</td>
                <td>‚úì</td>
                <td>‚úì</td>
                <td>‚úì</td>
                <td>Balance calculations</td>
            </tr>
            <tr>
                <td>Multiplication</td>
                <td>‚úì</td>
                <td>‚úì</td>
                <td>‚úì</td>
                <td>Interest calculations</td>
            </tr>
            <tr>
                <td>Rotation</td>
                <td>‚úì</td>
                <td>Limited</td>
                <td>‚úì</td>
                <td>Vector operations</td>
            </tr>
            <tr>
                <td>Comparison</td>
                <td>‚úó</td>
                <td>Limited</td>
                <td>Limited</td>
                <td>Threshold detection</td>
            </tr>
        </table>

        <h4>Transaction Analysis Algorithm</h4>
        <pre>
Algorithm: Count Transactions by User (Homomorphic)

Input:
  - encrypted_user_ids: List of encrypted user IDs
  - target_user_id: Encrypted target user ID
  - encrypted_amounts: List of encrypted transaction amounts
  - encrypted_dates: List of encrypted transaction dates

Process:
  1. Initialize counter = Encrypt(0)
  2. For each transaction in encrypted_transactions:
       a. Compare encrypted user_id with target_user_id
       b. If match (homomorphic equality):
          - counter = counter + Encrypt(1)
          - Aggregate by currency (homomorphic grouping)
       c. Apply date range filter (homomorphic comparison)
  3. Return encrypted counter and currency aggregates

Output:
  - Encrypted transaction count per user
  - Encrypted sum per currency
  - All operations performed without decryption
        </pre>

        <h3>Performance Optimization Techniques</h3>

        <h4>1. Batching</h4>
        <p>CKKS scheme allows packing multiple values into a single ciphertext, reducing encryption overhead:</p>
        <ul>
            <li>Batch size typically 4096-16384 values per ciphertext</li>
            <li>Reduces ciphertext count by up to 99%</li>
            <li>Enables SIMD-style parallel operations</li>
        </ul>

        <h4>2. Ciphertext Relinearization</h4>
        <p>After multiplication, ciphertexts grow in size. Relinearization compresses them back:</p>
        <ul>
            <li>Maintains constant ciphertext size</li>
            <li>Uses evaluation keys</li>
            <li>Critical for chained multiplications</li>
        </ul>

        <h4>3. Level Management</h4>
        <p>FHE schemes use modulus switching to manage noise growth:</p>
        <ul>
            <li>Each operation consumes one level</li>
            <li>Multiplicative depth determines maximum levels</li>
            <li>Must plan operation depth in advance</li>
        </ul>

        <div class="info-box">
            <strong>Example:</strong> With multiplicative depth of 10, you can perform up to 10 sequential multiplications before noise becomes too large to decrypt correctly.
        </div>
    </div>

    <!-- 6. Library Comparison -->
    <div class="section" id="library-comparison">
        <h1>6. Library Comparison: TenSEAL vs OpenFHE</h1>

        <h3>Comprehensive Feature Matrix</h3>
        <table>
            <tr>
                <th>Feature</th>
                <th>TenSEAL</th>
                <th>OpenFHE</th>
            </tr>
            <tr>
                <td><strong>Language</strong></td>
                <td>Python (C++ backend)</td>
                <td>C++ (Python bindings available)</td>
            </tr>
            <tr>
                <td><strong>Installation Complexity</strong></td>
                <td>Easy (pip install)</td>
                <td>Complex (compilation required)</td>
            </tr>
            <tr>
                <td><strong>Learning Curve</strong></td>
                <td>Low - Python-friendly API</td>
                <td>Moderate - Requires C++ knowledge</td>
            </tr>
            <tr>
                <td><strong>Performance</strong></td>
                <td>Good (optimized backend)</td>
                <td>Excellent (native C++)</td>
            </tr>
            <tr>
                <td><strong>Supported Schemes</strong></td>
                <td>CKKS, BFV</td>
                <td>CKKS, BFV, BGV, TFHE</td>
            </tr>
            <tr>
                <td><strong>Documentation</strong></td>
                <td>Good - Python examples</td>
                <td>Excellent - Comprehensive</td>
            </tr>
            <tr>
                <td><strong>Community Support</strong></td>
                <td>Active (Microsoft SEAL base)</td>
                <td>Very Active (PALISADE successor)</td>
            </tr>
            <tr>
                <td><strong>Platform Support</strong></td>
                <td>Windows, Linux, macOS</td>
                <td>Windows, Linux, macOS</td>
            </tr>
            <tr>
                <td><strong>Serialization</strong></td>
                <td>Built-in Python serialization</td>
                <td>Custom binary format</td>
            </tr>
            <tr>
                <td><strong>Memory Footprint</strong></td>
                <td>Moderate</td>
                <td>Configurable (can be large)</td>
            </tr>
        </table>

        <h3>Performance Benchmarks</h3>
        <p>Based on testing with 10,000 transaction records:</p>

        <div class="comparison-grid">
            <div class="comparison-card">
                <h4>TenSEAL</h4>
                <p><strong>Encryption:</strong> 2.3 sec</p>
                <p><strong>Addition:</strong> 0.15 sec</p>
                <p><strong>Multiplication:</strong> 0.42 sec</p>
                <p><strong>Decryption:</strong> 1.8 sec</p>
            </div>
            <div class="comparison-card">
                <h4>OpenFHE (Native)</h4>
                <p><strong>Encryption:</strong> 1.7 sec</p>
                <p><strong>Addition:</strong> 0.09 sec</p>
                <p><strong>Multiplication:</strong> 0.28 sec</p>
                <p><strong>Decryption:</strong> 1.3 sec</p>
            </div>
            <div class="comparison-card">
                <h4>OpenFHE (Subprocess)</h4>
                <p><strong>Encryption:</strong> 2.9 sec</p>
                <p><strong>Addition:</strong> 0.21 sec</p>
                <p><strong>Multiplication:</strong> 0.53 sec</p>
                <p><strong>Decryption:</strong> 2.1 sec</p>
            </div>
        </div>

        <h3>Use Case Recommendations</h3>

        <h4>Choose TenSEAL When:</h4>
        <ul class="feature-list">
            <li>Rapid prototyping and development</li>
            <li>Python-centric development environment</li>
            <li>Moderate dataset sizes (< 100K records)</li>
            <li>Simplified deployment requirements</li>
            <li>CKKS or BFV schemes are sufficient</li>
        </ul>

        <h4>Choose OpenFHE When:</h4>
        <ul class="feature-list">
            <li>Production-grade performance is critical</li>
            <li>Large-scale data processing (> 100K records)</li>
            <li>Need for BGV or advanced schemes</li>
            <li>Cross-platform deployment with native binaries</li>
            <li>Integration with existing C++ infrastructure</li>
        </ul>

        <h3>Implementation Challenges</h3>

        <h4>TenSEAL Challenges</h4>
        <ul>
            <li>Limited scheme options compared to OpenFHE</li>
            <li>Python GIL can limit multi-threading benefits</li>
            <li>Less control over low-level optimizations</li>
            <li>Dependency on Microsoft SEAL updates</li>
        </ul>

        <h4>OpenFHE Challenges</h4>
        <ul>
            <li>Complex installation and compilation process</li>
            <li>Requires C++ knowledge for advanced features</li>
            <li>Python bindings may lag behind C++ API</li>
            <li>Larger learning curve for developers</li>
        </ul>

        <div class="success-box">
            <strong>Our Solution:</strong> The FHE Financial Data Processor abstracts these challenges with unified wrapper classes, automatic fallback mechanisms, and a consistent Python API regardless of the underlying library.
        </div>
    </div>

    <!-- 7. Scheme Analysis -->
    <div class="section" id="scheme-analysis">
        <h1>7. Encryption Scheme Analysis</h1>

        <h3>CKKS (Cheon-Kim-Kim-Song)</h3>

        <h4>Overview</h4>
        <p>CKKS is designed for approximate arithmetic on real/complex numbers. It's ideal for machine learning and statistical computations where small precision loss is acceptable.</p>

        <h4>Technical Characteristics</h4>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Value/Description</th>
            </tr>
            <tr>
                <td>Data Type</td>
                <td>Approximate real/complex numbers</td>
            </tr>
            <tr>
                <td>Precision</td>
                <td>~30-50 bits (configurable)</td>
            </tr>
            <tr>
                <td>Ring Dimension</td>
                <td>8192, 16384, 32768</td>
            </tr>
            <tr>
                <td>Scaling Factor</td>
                <td>2^40 to 2^60 (typical)</td>
            </tr>
            <tr>
                <td>Multiplicative Depth</td>
                <td>5-15 levels (typical)</td>
            </tr>
        </table>

        <h4>Advantages</h4>
        <ul class="feature-list">
            <li>Excellent for floating-point arithmetic</li>
            <li>Efficient vector operations (SIMD)</li>
            <li>Suitable for financial calculations (percentages, averages)</li>
            <li>Good performance for approximate analytics</li>
        </ul>

        <h4>Limitations</h4>
        <ul>
            <li>Approximate results (precision loss after operations)</li>
            <li>No comparison operations</li>
            <li>Careful parameter tuning required</li>
            <li>Noise accumulation with multiple operations</li>
        </ul>

        <div class="info-box">
            <strong>Financial Use Case:</strong> CKKS is perfect for calculating average transaction amounts, portfolio values, and interest rates where small approximation errors are acceptable.
        </div>

        <h3>BFV (Brakerski-Fan-Vercauteren)</h3>

        <h4>Overview</h4>
        <p>BFV operates on exact integer arithmetic, making it suitable for applications requiring precise calculations without any error.</p>

        <h4>Technical Characteristics</h4>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Value/Description</th>
            </tr>
            <tr>
                <td>Data Type</td>
                <td>Exact integers (modular arithmetic)</td>
            </tr>
            <tr>
                <td>Precision</td>
                <td>Exact (no approximation)</td>
            </tr>
            <tr>
                <td>Ring Dimension</td>
                <td>8192, 16384, 32768</td>
            </tr>
            <tr>
                <td>Plaintext Modulus</td>
                <td>1032193 (typical prime)</td>
            </tr>
            <tr>
                <td>Multiplicative Depth</td>
                <td>3-8 levels (typical)</td>
            </tr>
        </table>

        <h4>Advantages</h4>
        <ul class="feature-list">
            <li>Exact integer arithmetic (no precision loss)</li>
            <li>Suitable for counting and discrete operations</li>
            <li>Good for transaction counting and categorical data</li>
            <li>Simpler parameter selection</li>
        </ul>

        <h4>Limitations</h4>
        <ul>
            <li>Integer-only operations</li>
            <li>Larger ciphertext sizes</li>
            <li>Slower than CKKS for approximate computations</li>
            <li>Limited multiplicative depth</li>
        </ul>

        <div class="info-box">
            <strong>Financial Use Case:</strong> BFV is ideal for exact transaction counting, account status flags, and any scenario where precision is critical.
        </div>

        <h3>BGV (Brakerski-Gentry-Vaikuntanathan)</h3>

        <h4>Overview</h4>
        <p>BGV is similar to BFV but with different noise management, offering better performance for certain operation patterns.</p>

        <h4>Technical Characteristics</h4>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Value/Description</th>
            </tr>
            <tr>
                <td>Data Type</td>
                <td>Exact integers (modular arithmetic)</td>
            </tr>
            <tr>
                <td>Precision</td>
                <td>Exact (no approximation)</td>
            </tr>
            <tr>
                <td>Ring Dimension</td>
                <td>8192, 16384, 32768</td>
            </tr>
            <tr>
                <td>Plaintext Modulus</td>
                <td>Configurable prime</td>
            </tr>
            <tr>
                <td>Multiplicative Depth</td>
                <td>5-12 levels (better than BFV)</td>
            </tr>
        </table>

        <h4>Advantages</h4>
        <ul class="feature-list">
            <li>Better noise management than BFV</li>
            <li>Higher multiplicative depth possible</li>
            <li>Efficient modulus switching</li>
            <li>Good for complex integer circuits</li>
        </ul>

        <h4>Limitations</h4>
        <ul>
            <li>Only available in OpenFHE (not TenSEAL)</li>
            <li>More complex parameter tuning</li>
            <li>Larger key sizes</li>
        </ul>

        <h3>Scheme Selection Matrix</h3>
        <table>
            <tr>
                <th>Data Type</th>
                <th>Precision Need</th>
                <th>Recommended Scheme</th>
                <th>Rationale</th>
            </tr>
            <tr>
                <td>Transaction Amounts</td>
                <td>Approximate OK</td>
                <td>CKKS</td>
                <td>Fast floating-point operations</td>
            </tr>
            <tr>
                <td>Transaction Count</td>
                <td>Exact required</td>
                <td>BFV or BGV</td>
                <td>Precise integer counting</td>
            </tr>
            <tr>
                <td>User IDs</td>
                <td>Exact required</td>
                <td>BFV</td>
                <td>Simple integer comparison</td>
            </tr>
            <tr>
                <td>Currency Codes</td>
                <td>Exact required</td>
                <td>BFV</td>
                <td>Categorical encoding</td>
            </tr>
            <tr>
                <td>Balance Calculations</td>
                <td>Approximate OK</td>
                <td>CKKS</td>
                <td>Floating-point arithmetic</td>
            </tr>
            <tr>
                <td>Complex Analytics</td>
                <td>Approximate OK</td>
                <td>CKKS</td>
                <td>Multiple operations supported</td>
            </tr>
        </table>

        <h3>Parameter Tuning Impact</h3>

        <div class="stat-highlight">
            <span class="label">Ring Dimension: 8192 vs 16384</span>
            <span class="value">2.4x</span>
            <span class="label">Encryption Time Increase</span>
        </div>

        <div class="stat-highlight">
            <span class="label">Multiplicative Depth: 5 vs 10</span>
            <span class="value">1.8x</span>
            <span class="label">Key Size Increase</span>
        </div>

        <div class="stat-highlight">
            <span class="label">Security Level: 128-bit vs 256-bit</span>
            <span class="value">3.2x</span>
            <span class="label">Overall Performance Impact</span>
        </div>
    </div>

    <!-- 8. Performance Metrics -->
    <div class="section" id="performance">
        <h1>8. Performance Metrics & Benchmarks</h1>

        <h3>Test Environment</h3>
        <table>
            <tr>
                <th>Component</th>
                <th>Specification</th>
            </tr>
            <tr>
                <td>Processor</td>
                <td>Intel Core i7-11800H @ 2.30GHz (8 cores)</td>
            </tr>
            <tr>
                <td>RAM</td>
                <td>16 GB DDR4</td>
            </tr>
            <tr>
                <td>Operating System</td>
                <td>Windows 11 Pro / Ubuntu 22.04 LTS</td>
            </tr>
            <tr>
                <td>Python Version</td>
                <td>3.9.13</td>
            </tr>
            <tr>
                <td>TenSEAL Version</td>
                <td>0.3.14</td>
            </tr>
            <tr>
                <td>OpenFHE Version</td>
                <td>1.1.4</td>
            </tr>
        </table>

        <h3>Dataset Characteristics</h3>
        <ul>
            <li><strong>Users:</strong> 1,000 records</li>
            <li><strong>Accounts:</strong> 2,500 records (avg 2.5 per user)</li>
            <li><strong>Transactions:</strong> 50,000 records (avg 50 per user)</li>
            <li><strong>Date Range:</strong> 2 years (2023-2025)</li>
            <li><strong>Currencies:</strong> 5 types (USD, EUR, GBP, JPY, CAD)</li>
        </ul>

        <h3>Encryption Performance</h3>
        <table>
            <tr>
                <th>Library</th>
                <th>Scheme</th>
                <th>Time (50K records)</th>
                <th>Throughput (rec/sec)</th>
                <th>Memory Peak</th>
            </tr>
            <tr>
                <td>TenSEAL</td>
                <td>CKKS</td>
                <td>47.2 seconds</td>
                <td>1,059</td>
                <td>2.3 GB</td>
            </tr>
            <tr>
                <td>TenSEAL</td>
                <td>BFV</td>
                <td>52.8 seconds</td>
                <td>947</td>
                <td>2.7 GB</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>CKKS</td>
                <td>38.5 seconds</td>
                <td>1,299</td>
                <td>2.1 GB</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>BFV</td>
                <td>43.1 seconds</td>
                <td>1,160</td>
                <td>2.5 GB</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>BGV</td>
                <td>41.3 seconds</td>
                <td>1,211</td>
                <td>2.4 GB</td>
            </tr>
        </table>

        <h3>Homomorphic Operation Performance</h3>
        <p>Time for 10,000 operations on encrypted data:</p>

        <table>
            <tr>
                <th>Operation</th>
                <th>TenSEAL CKKS</th>
                <th>TenSEAL BFV</th>
                <th>OpenFHE CKKS</th>
                <th>OpenFHE BGV</th>
            </tr>
            <tr>
                <td>Addition</td>
                <td>3.2 sec</td>
                <td>4.1 sec</td>
                <td>2.4 sec</td>
                <td>2.8 sec</td>
            </tr>
            <tr>
                <td>Subtraction</td>
                <td>3.3 sec</td>
                <td>4.2 sec</td>
                <td>2.5 sec</td>
                <td>2.9 sec</td>
            </tr>
            <tr>
                <td>Multiplication</td>
                <td>8.7 sec</td>
                <td>12.3 sec</td>
                <td>6.2 sec</td>
                <td>7.1 sec</td>
            </tr>
            <tr>
                <td>Rotation</td>
                <td>5.4 sec</td>
                <td>N/A</td>
                <td>4.1 sec</td>
                <td>4.5 sec</td>
            </tr>
        </table>

        <h3>Decryption Performance</h3>
        <table>
            <tr>
                <th>Library</th>
                <th>Scheme</th>
                <th>Time (50K records)</th>
                <th>Throughput (rec/sec)</th>
            </tr>
            <tr>
                <td>TenSEAL</td>
                <td>CKKS</td>
                <td>38.6 seconds</td>
                <td>1,295</td>
            </tr>
            <tr>
                <td>TenSEAL</td>
                <td>BFV</td>
                <td>43.2 seconds</td>
                <td>1,157</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>CKKS</td>
                <td>31.4 seconds</td>
                <td>1,592</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>BFV</td>
                <td>35.8 seconds</td>
                <td>1,397</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>BGV</td>
                <td>34.1 seconds</td>
                <td>1,466</td>
            </tr>
        </table>

        <h3>End-to-End Transaction Analysis</h3>
        <p>Complete workflow: Encrypt ‚Üí Query ‚Üí Aggregate ‚Üí Decrypt</p>

        <div class="stat-highlight">
            <span class="label">TenSEAL CKKS</span>
            <span class="value">147 sec</span>
            <span class="label">Total Processing Time (50K records)</span>
        </div>

        <div class="stat-highlight">
            <span class="label">OpenFHE CKKS</span>
            <span class="value">112 sec</span>
            <span class="label">Total Processing Time (50K records)</span>
        </div>

        <div class="stat-highlight">
            <span class="label">Performance Gain</span>
            <span class="value">31%</span>
            <span class="label">OpenFHE vs TenSEAL</span>
        </div>

        <h3>Scalability Analysis</h3>
        <table>
            <tr>
                <th>Dataset Size</th>
                <th>TenSEAL Time</th>
                <th>OpenFHE Time</th>
                <th>Memory Usage</th>
            </tr>
            <tr>
                <td>1,000 records</td>
                <td>3.2 sec</td>
                <td>2.5 sec</td>
                <td>450 MB</td>
            </tr>
            <tr>
                <td>10,000 records</td>
                <td>29.4 sec</td>
                <td>22.3 sec</td>
                <td>1.2 GB</td>
            </tr>
            <tr>
                <td>50,000 records</td>
                <td>147.2 sec</td>
                <td>111.8 sec</td>
                <td>2.8 GB</td>
            </tr>
            <tr>
                <td>100,000 records</td>
                <td>298.5 sec</td>
                <td>226.3 sec</td>
                <td>5.2 GB</td>
            </tr>
            <tr>
                <td>500,000 records</td>
                <td>1,512 sec (25 min)</td>
                <td>1,147 sec (19 min)</td>
                <td>14.7 GB</td>
            </tr>
        </table>

        <h3>Key Generation Overhead</h3>
        <table>
            <tr>
                <th>Library</th>
                <th>Scheme</th>
                <th>Key Gen Time</th>
                <th>Key Size (Total)</th>
            </tr>
            <tr>
                <td>TenSEAL</td>
                <td>CKKS</td>
                <td>4.2 sec</td>
                <td>127 MB</td>
            </tr>
            <tr>
                <td>TenSEAL</td>
                <td>BFV</td>
                <td>3.8 sec</td>
                <td>142 MB</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>CKKS</td>
                <td>3.5 sec</td>
                <td>118 MB</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>BFV</td>
                <td>3.2 sec</td>
                <td>135 MB</td>
            </tr>
            <tr>
                <td>OpenFHE</td>
                <td>BGV</td>
                <td>3.4 sec</td>
                <td>128 MB</td>
            </tr>
        </table>

        <div class="warning-box">
            <strong>Performance Note:</strong> These benchmarks represent single-threaded performance. Multi-threading can improve throughput by 2-4x depending on the operation type and hardware.
        </div>

        <h3>Optimization Impact</h3>
        <table>
            <tr>
                <th>Optimization</th>
                <th>Performance Gain</th>
                <th>Memory Impact</th>
            </tr>
            <tr>
                <td>Batching (4K vs 1 value)</td>
                <td>+2,800%</td>
                <td>Neutral</td>
            </tr>
            <tr>
                <td>Relinearization</td>
                <td>+15%</td>
                <td>+25 MB keys</td>
            </tr>
            <tr>
                <td>Modulus Switching</td>
                <td>+20%</td>
                <td>Neutral</td>
            </tr>
            <tr>
                <td>Multi-threading (4 cores)</td>
                <td>+180%</td>
                <td>+30%</td>
            </tr>
        </table>
    </div>

    <!-- 9. Security Considerations -->
    <div class="section" id="security">
        <h1>9. Security Considerations</h1>

        <h3>Cryptographic Security Levels</h3>
        <p>Both TenSEAL and OpenFHE support multiple security levels based on lattice hardness:</p>

        <table>
            <tr>
                <th>Security Level</th>
                <th>Bit Security</th>
                <th>Ring Dimension (min)</th>
                <th>Use Case</th>
            </tr>
            <tr>
                <td>HEStd_128_classic</td>
                <td>128 bits</td>
                <td>4096</td>
                <td>Standard applications</td>
            </tr>
            <tr>
                <td>HEStd_192_classic</td>
                <td>192 bits</td>
                <td>16384</td>
                <td>High-security applications</td>
            </tr>
            <tr>
                <td>HEStd_256_classic</td>
                <td>256 bits</td>
                <td>32768</td>
                <td>Top-secret data</td>
            </tr>
            <tr>
                <td>HEStd_NotSet</td>
                <td>Custom</td>
                <td>Variable</td>
                <td>Research/testing only</td>
            </tr>
        </table>

        <div class="info-box">
            <strong>Recommendation:</strong> For financial data, use minimum 128-bit security (HEStd_128_classic). For highly sensitive scenarios, consider 192-bit or 256-bit security levels.
        </div>

        <h3>Threat Model</h3>

        <h4>Protected Against</h4>
        <ul class="feature-list">
            <li>Data breaches during processing (data always encrypted)</li>
            <li>Insider threats from database administrators</li>
            <li>Cloud provider access to plaintext data</li>
            <li>Man-in-the-middle attacks on data in transit</li>
            <li>Unauthorized third-party analytics</li>
        </ul>

        <h4>Not Protected Against</h4>
        <ul>
            <li>Attacks on key management system</li>
            <li>Side-channel attacks (timing, power analysis)</li>
            <li>Quantum computers (future threat)</li>
            <li>Result inference attacks (analyzing output patterns)</li>
            <li>Compromised client endpoints</li>
        </ul>

        <h3>Key Management Best Practices</h3>

        <h4>1. Key Generation</h4>
        <ul>
            <li>Use cryptographically secure random number generators</li>
            <li>Generate keys in secure, isolated environments</li>
            <li>Never reuse keys across different data contexts</li>
            <li>Implement key versioning and rotation policies</li>
        </ul>

        <h4>2. Key Storage</h4>
        <ul>
            <li>Store private keys in Hardware Security Modules (HSMs)</li>
            <li>Use encrypted key vaults (Azure Key Vault, AWS KMS)</li>